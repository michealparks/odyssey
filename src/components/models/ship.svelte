<!--
Auto-generated by: https://github.com/threlte/threlte/tree/main/packages/gltf
Command: npx @threlte/gltf@0.0.5 src/glb/ship.glb --output src/models/ship.svelte --types --keepnames --meta --shadows --debug
-->
<script lang="ts">

import * as THREE from 'three'
import { Group } from 'three'
import { T, useFrame, useThrelte, type Props, type Events, type Slots } from '@threlte/core'
import { useGltf } from '@threlte/extras'
import { Collider } from '@threlte/rapier'

type $$Props = Props<THREE.Group>
type $$Events = Events<THREE.Group>
type $$Slots = Slots<THREE.Group>

export const ref = new Group()

type GLTFResult = {
  nodes: {
    person: THREE.Mesh
    exterior_top: THREE.Mesh
    exterior_bottom: THREE.Mesh
    exterior_middle_bottom: THREE.Mesh
    exterior_middle_top: THREE.Mesh
    floor_top: THREE.Mesh
    floor_center: THREE.Mesh
    stasis_chamber: THREE.Mesh
    floor_bottom: THREE.Mesh
  }
  materials: {
    Exterior: THREE.MeshStandardMaterial
    Material: THREE.MeshStandardMaterial
  }
}

const gltf = useGltf<GLTFResult>('./glb/ship.glb')

let level = 4

let walls1: THREE.Mesh
let walls2: THREE.Mesh
let walls3: THREE.Mesh

let floors1: THREE.Mesh
let floors2: THREE.Mesh

const { renderer, scene } = useThrelte()

const metalness = 0.9
const roughness = 0

const size = 512
const cubeRenderTarget = new THREE.WebGLCubeRenderTarget(size)
const mirrorSphereCamera = new THREE.CubeCamera(10, 2000, cubeRenderTarget)

scene.add(mirrorSphereCamera)

mirrorSphereCamera.renderTarget.depthBuffer = false

const handleFloorClick = (e) => {
  console.log(e)
}

useFrame(() => {
  mirrorSphereCamera.update(renderer, scene)
})

document.addEventListener('keyup', (e) => {
  const key = Number.parseInt(e.key.toLowerCase(), 10)

  if ([1, 2, 3, 4].includes(key) === false) {
    return
  }

  level = key

}, { passive: true })

$: {
  if (walls1 && walls2 && walls3) {
    walls1.visible = level > 3
    walls2.visible = level > 2
    walls3.visible = level > 1
  }

  if (floors1 && floors2) {
    floors1.visible = level > 2
    floors2.visible = level > 1
  }
}

</script>

{#if $gltf}
  <T is={ref} {...$$restProps} rotation={[0, -Math.PI / 2, 0]}>
    <!-- top section -->
    <Collider
      shape='cylinder'
      position={[-2, 5.35, 0]}
      args={[1.3, 0.9]}
    />
    <T.Mesh
      name="stasis_chamber"
      castShadow
      receiveShadow
      geometry={$gltf.nodes.stasis_chamber.geometry}
      material={$gltf.nodes.stasis_chamber.material}
      position={[-2, 5.35, 0]}
      userData={{ name: 'stasis_chamber' }}
    />

    <T.Mesh
      bind:ref={walls1}
      name="exterior_top"
      receiveShadow
      geometry={$gltf.nodes.exterior_top.geometry}
    >
      <T
        is={$gltf.materials.Exterior}
        {metalness}
        {roughness}
        envMap={cubeRenderTarget.texture}
        envMapIntensity={0.8}
      />
    </T.Mesh>
    <T.Mesh
      bind:ref={walls2}
      name="exterior_middle_top"
      receiveShadow
      geometry={$gltf.nodes.exterior_middle_top.geometry}
    >
      <T
        is={$gltf.materials.Exterior}
        {metalness}
        {roughness}
        envMap={cubeRenderTarget.texture}
        envMapIntensity={0.8}
      />
    </T.Mesh>
    <T.Mesh
      bind:ref={walls3}
      name="exterior_middle_bottom"
      receiveShadow
      geometry={$gltf.nodes.exterior_middle_bottom.geometry}
    >
      <T
        is={$gltf.materials.Exterior}
        {metalness}
        {roughness}
        envMap={cubeRenderTarget.texture}
        envMapIntensity={0.8}
      />
    </T.Mesh>
    <T.Mesh
      name="exterior_bottom"
      receiveShadow
      geometry={$gltf.nodes.exterior_bottom.geometry}
    >
      <T
        is={$gltf.materials.Exterior}
        {metalness}
        {roughness}
        envMap={cubeRenderTarget.texture}
        envMapIntensity={0.8}
      />
    </T.Mesh>

    <Collider
      shape='cylinder'
      position={[0, 3.87, 0]}
      args={[0.1, 7.15]}
    >
      <T.Mesh
        bind:ref={floors1}
        name="floor_top"
        receiveShadow
        geometry={$gltf.nodes.floor_top.geometry}
        material={$gltf.nodes.floor_top.material}
        on:click={handleFloorClick}
      />
    </Collider>
    
    <Collider 
      shape='cylinder'
      args={[0.1, 8.25]}
    />
    <T.Mesh
      bind:ref={floors2}
      name="floor_center"
      receiveShadow
      geometry={$gltf.nodes.floor_center.geometry}
      material={$gltf.nodes.floor_center.material}
      position={[0, -0.29, 0]}
      on:click={handleFloorClick}
    />

    <Collider
      shape='cylinder'
      position={[0, -4.13, 0]}
      args={[0.1, 7.15]}
    >
      <T.Mesh
        name="floor_bottom"
        receiveShadow
        geometry={$gltf.nodes.floor_bottom.geometry}
        material={$gltf.nodes.floor_bottom.material}
        on:click={handleFloorClick}
      />
    </Collider>

    <slot {ref} />
  </T>
{/if}
